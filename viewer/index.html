<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Gaussian Splatting Interactive Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0f0f23 100%);
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
        }
        
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 30, 0.9);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(0, 170, 255, 0.3);
            backdrop-filter: blur(10px);
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #controls h2 {
            color: #00aaff;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #controls h2::before {
            content: '◉';
            color: #00ff88;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .control-group h3 {
            color: #aaa;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        #controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0 3px;
            color: #ccc;
            font-size: 13px;
        }
        
        #controls input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 5px 0;
        }
        
        #controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #00aaff, #00ff88);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 170, 255, 0.5);
        }
        
        .val {
            color: #00aaff;
            font-weight: 600;
            min-width: 50px;
            text-align: right;
        }
        
        .btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #00aaff, #0066cc);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 170, 255, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ccc;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #00ff88;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 30, 0.8);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 12px;
            color: #888;
            backdrop-filter: blur(10px);
        }
        
        #info span {
            color: #00aaff;
            font-weight: 600;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 30, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0, 170, 255, 0.2);
            border-top-color: #00aaff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #loading p {
            font-size: 16px;
            color: #aaa;
        }
        
        #loading .progress {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 15px;
            overflow: hidden;
        }
        
        #loading .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ff88);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .help-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 30, 0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        .help-panel h4 {
            color: #00aaff;
            margin-bottom: 10px;
            font-size: 13px;
        }
        
        .help-panel p {
            color: #888;
            margin: 5px 0;
        }
        
        .help-panel kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: #fff;
        }
        
        select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
        }
        
        select option {
            background: #1a1a2e;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p id="loadingText">Initializing WebGL...</p>
        <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <h2>3D Gaussian Splatting</h2>
        
        <div class="control-group">
            <h3>Render Mode</h3>
            <select id="renderMode">
                <option value="mip">Maximum Intensity Projection (MIP)</option>
                <option value="alpha">Alpha Blending</option>
                <option value="average">Average Intensity</option>
                <option value="xray">X-Ray Style</option>
            </select>
        </div>
        
        <div class="control-group">
            <h3>Display Settings</h3>
            <label>Brightness <span class="val" id="brightVal">1.5</span></label>
            <input type="range" id="brightness" min="0.1" max="5" step="0.1" value="1.5">
            
            <label>Contrast <span class="val" id="contrastVal">1.0</span></label>
            <input type="range" id="contrast" min="0.5" max="3" step="0.1" value="1.0">
            
            <label>Threshold <span class="val" id="threshVal">0.00</span></label>
            <input type="range" id="threshold" min="0" max="0.5" step="0.01" value="0">
            
            <label>Gaussian Size <span class="val" id="sizeVal">1.0</span></label>
            <input type="range" id="gaussianSize" min="0.2" max="3" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <h3>Camera</h3>
            <label>Field of View <span class="val" id="fovVal">45°</span></label>
            <input type="range" id="fov" min="20" max="90" step="1" value="45">
            
            <label>Zoom <span class="val" id="zoomVal">2.0</span></label>
            <input type="range" id="zoom" min="0.5" max="5" step="0.1" value="2.0">
        </div>
        
        <div class="control-group">
            <h3>Animation</h3>
            <button class="btn btn-secondary" id="autoRotate">Auto Rotate</button>
            <label>Speed <span class="val" id="speedVal">1.0</span></label>
            <input type="range" id="speed" min="0" max="5" step="0.1" value="1.0">
        </div>
        
        <div class="control-group">
            <h3>Color Mapping</h3>
            <select id="colorMap">
                <option value="grayscale">Grayscale</option>
                <option value="viridis">Viridis</option>
                <option value="plasma">Plasma</option>
                <option value="hot">Hot</option>
                <option value="cool">Cool</option>
                <option value="bone">Bone</option>
            </select>
        </div>
        
        <div class="control-group">
            <button class="btn btn-primary" id="resetView">Reset View</button>
            <button class="btn btn-secondary" id="screenshot">Screenshot</button>
        </div>
    </div>
    
    <div id="info">
        Gaussians: <span id="numGaussians">0</span> | 
        FPS: <span id="fps">0</span> | 
        Resolution: <span id="resolution">0×0</span>
    </div>
    
    <div class="help-panel">
        <h4>Controls</h4>
        <p><kbd>Drag</kbd> Rotate view</p>
        <p><kbd>Scroll</kbd> Zoom in/out</p>
        <p><kbd>R</kbd> Reset view</p>
        <p><kbd>Space</kbd> Toggle rotation</p>
    </div>

<!-- Vertex Shader for Gaussian Splatting -->
<script id="gaussianVS" type="x-shader/x-vertex">#version 300 es
precision highp float;

in vec3 aPosition;
in vec3 aScale;
in vec4 aRotation;
in float aOpacity;

uniform mat4 uProjection;
uniform mat4 uView;
uniform vec3 uVolumeDims;
uniform float uSizeMultiplier;

out vec3 vColor;
out float vOpacity;
out vec2 vOffset;
out vec3 vCovA;
out vec3 vCovB;

// Quaternion to rotation matrix
mat3 quatToMat(vec4 q) {
    float x = q.x, y = q.y, z = q.z, w = q.w;
    return mat3(
        1.0 - 2.0*(y*y + z*z), 2.0*(x*y - w*z), 2.0*(x*z + w*y),
        2.0*(x*y + w*z), 1.0 - 2.0*(x*x + z*z), 2.0*(y*z - w*x),
        2.0*(x*z - w*y), 2.0*(y*z + w*x), 1.0 - 2.0*(x*x + y*y)
    );
}

void main() {
    // Transform position from normalized [0,1] to centered world space
    vec3 worldPos = (aPosition - 0.5) * uVolumeDims;
    
    // Transform to view space
    vec4 viewPos = uView * vec4(worldPos, 1.0);
    
    // Calculate 2D covariance for splatting
    mat3 R = quatToMat(aRotation);
    vec3 scale = aScale * uSizeMultiplier;
    mat3 S = mat3(
        scale.x, 0.0, 0.0,
        0.0, scale.y, 0.0,
        0.0, 0.0, scale.z
    );
    mat3 cov3D = R * S * S * transpose(R);
    
    // Project to 2D covariance
    mat3 J = mat3(
        1.0 / viewPos.z, 0.0, -viewPos.x / (viewPos.z * viewPos.z),
        0.0, 1.0 / viewPos.z, -viewPos.y / (viewPos.z * viewPos.z),
        0.0, 0.0, 0.0
    );
    mat3 W = mat3(uView);
    mat3 T = W * J;
    mat3 cov2D = transpose(T) * cov3D * T;
    
    // Store covariance components for fragment shader
    vCovA = vec3(cov2D[0][0], cov2D[0][1], cov2D[1][1]);
    
    // Calculate size for point sprite
    float det = cov2D[0][0] * cov2D[1][1] - cov2D[0][1] * cov2D[0][1];
    float radius = sqrt(max(cov2D[0][0], cov2D[1][1])) * 3.0;
    
    vOpacity = aOpacity;
    vColor = vec3(aOpacity); // Simple grayscale for now
    
    gl_Position = uProjection * viewPos;
    gl_PointSize = radius * 500.0 / (-viewPos.z);
}
</script>

<!-- Fragment Shader for Gaussian Splatting -->
<script id="gaussianFS" type="x-shader/x-fragment">#version 300 es
precision highp float;

in vec3 vColor;
in float vOpacity;
in vec3 vCovA;

uniform float uBrightness;
uniform float uContrast;
uniform float uThreshold;
uniform int uRenderMode;
uniform int uColorMap;

out vec4 fragColor;

vec3 viridis(float t) {
    const vec3 c0 = vec3(0.267, 0.004, 0.329);
    const vec3 c1 = vec3(0.282, 0.140, 0.457);
    const vec3 c2 = vec3(0.254, 0.265, 0.530);
    const vec3 c3 = vec3(0.163, 0.471, 0.558);
    const vec3 c4 = vec3(0.134, 0.658, 0.517);
    const vec3 c5 = vec3(0.477, 0.821, 0.318);
    const vec3 c6 = vec3(0.993, 0.906, 0.144);
    
    t = clamp(t, 0.0, 1.0);
    if (t < 0.167) return mix(c0, c1, t / 0.167);
    if (t < 0.333) return mix(c1, c2, (t - 0.167) / 0.167);
    if (t < 0.5) return mix(c2, c3, (t - 0.333) / 0.167);
    if (t < 0.667) return mix(c3, c4, (t - 0.5) / 0.167);
    if (t < 0.833) return mix(c4, c5, (t - 0.667) / 0.167);
    return mix(c5, c6, (t - 0.833) / 0.167);
}

vec3 plasma(float t) {
    const vec3 c0 = vec3(0.050, 0.030, 0.528);
    const vec3 c1 = vec3(0.417, 0.001, 0.658);
    const vec3 c2 = vec3(0.694, 0.165, 0.564);
    const vec3 c3 = vec3(0.881, 0.392, 0.383);
    const vec3 c4 = vec3(0.988, 0.652, 0.195);
    const vec3 c5 = vec3(0.940, 0.975, 0.131);
    
    t = clamp(t, 0.0, 1.0);
    if (t < 0.2) return mix(c0, c1, t / 0.2);
    if (t < 0.4) return mix(c1, c2, (t - 0.2) / 0.2);
    if (t < 0.6) return mix(c2, c3, (t - 0.4) / 0.2);
    if (t < 0.8) return mix(c3, c4, (t - 0.6) / 0.2);
    return mix(c4, c5, (t - 0.8) / 0.2);
}

vec3 hot(float t) {
    t = clamp(t, 0.0, 1.0);
    return vec3(
        clamp(t * 3.0, 0.0, 1.0),
        clamp(t * 3.0 - 1.0, 0.0, 1.0),
        clamp(t * 3.0 - 2.0, 0.0, 1.0)
    );
}

vec3 cool(float t) {
    t = clamp(t, 0.0, 1.0);
    return vec3(t, 1.0 - t, 1.0);
}

vec3 bone(float t) {
    t = clamp(t, 0.0, 1.0);
    return vec3(
        t < 0.75 ? t * 8.0 / 9.0 : (t - 0.75) * 2.0 + 2.0/3.0,
        t < 0.375 ? t * 8.0 / 9.0 : (t < 0.75 ? (t - 0.375) * 8.0 / 9.0 + 1.0/3.0 : (t - 0.75) * 2.0 + 2.0/3.0),
        t < 0.375 ? t * 8.0 / 9.0 + 1.0/9.0 : 1.0/3.0 + (t - 0.375) * 16.0 / 9.0 / 1.5
    );
}

vec3 applyColorMap(float intensity) {
    if (uColorMap == 0) return vec3(intensity); // grayscale
    if (uColorMap == 1) return viridis(intensity);
    if (uColorMap == 2) return plasma(intensity);
    if (uColorMap == 3) return hot(intensity);
    if (uColorMap == 4) return cool(intensity);
    if (uColorMap == 5) return bone(intensity);
    return vec3(intensity);
}

void main() {
    // Calculate Gaussian falloff from point center
    vec2 offset = gl_PointCoord - 0.5;
    float dist2 = dot(offset, offset);
    
    // Gaussian evaluation
    float gaussian = exp(-dist2 * 8.0);
    
    if (gaussian < 0.01) discard;
    
    float intensity = vOpacity * gaussian;
    intensity = max(0.0, intensity - uThreshold);
    intensity = pow(intensity * uBrightness, uContrast);
    intensity = clamp(intensity, 0.0, 1.0);
    
    vec3 color = applyColorMap(intensity);
    
    // Different render modes affect alpha
    float alpha = intensity;
    if (uRenderMode == 1) { // Alpha blending
        alpha = intensity * 0.5;
    } else if (uRenderMode == 2) { // Average
        alpha = 0.1;
    } else if (uRenderMode == 3) { // X-Ray
        alpha = 1.0 - exp(-intensity * 2.0);
        color = vec3(1.0) - color;
    }
    
    fragColor = vec4(color, alpha);
}
</script>

<!-- Raymarching Vertex Shader -->
<script id="raymarchVS" type="x-shader/x-vertex">#version 300 es
in vec2 aPos;
out vec2 vUV;
void main() {
    vUV = aPos * 0.5 + 0.5;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
</script>

<!-- Raymarching Fragment Shader -->
<script id="raymarchFS" type="x-shader/x-fragment">#version 300 es
precision highp float;
precision highp sampler3D;

in vec2 vUV;
out vec4 fragColor;

uniform sampler3D uVolume;
uniform mat3 uRotation;
uniform float uZoom;
uniform float uBrightness;
uniform float uContrast;
uniform float uThreshold;
uniform vec3 uAspect;
uniform vec2 uResolution;
uniform float uFOV;
uniform int uRenderMode;
uniform int uColorMap;

const int MAX_STEPS = 512;
const float STEP_SIZE = 0.002;

vec2 intersectBox(vec3 ro, vec3 rd, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - ro) / rd;
    vec3 tMax = (boxMax - ro) / rd;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
}

vec3 viridis(float t) {
    const vec3 c0 = vec3(0.267, 0.004, 0.329);
    const vec3 c1 = vec3(0.282, 0.140, 0.457);
    const vec3 c2 = vec3(0.254, 0.265, 0.530);
    const vec3 c3 = vec3(0.163, 0.471, 0.558);
    const vec3 c4 = vec3(0.134, 0.658, 0.517);
    const vec3 c5 = vec3(0.477, 0.821, 0.318);
    const vec3 c6 = vec3(0.993, 0.906, 0.144);
    
    t = clamp(t, 0.0, 1.0);
    if (t < 0.167) return mix(c0, c1, t / 0.167);
    if (t < 0.333) return mix(c1, c2, (t - 0.167) / 0.167);
    if (t < 0.5) return mix(c2, c3, (t - 0.333) / 0.167);
    if (t < 0.667) return mix(c3, c4, (t - 0.5) / 0.167);
    if (t < 0.833) return mix(c4, c5, (t - 0.667) / 0.167);
    return mix(c5, c6, (t - 0.833) / 0.167);
}

vec3 plasma(float t) {
    const vec3 c0 = vec3(0.050, 0.030, 0.528);
    const vec3 c1 = vec3(0.417, 0.001, 0.658);
    const vec3 c2 = vec3(0.694, 0.165, 0.564);
    const vec3 c3 = vec3(0.881, 0.392, 0.383);
    const vec3 c4 = vec3(0.988, 0.652, 0.195);
    const vec3 c5 = vec3(0.940, 0.975, 0.131);
    
    t = clamp(t, 0.0, 1.0);
    if (t < 0.2) return mix(c0, c1, t / 0.2);
    if (t < 0.4) return mix(c1, c2, (t - 0.2) / 0.2);
    if (t < 0.6) return mix(c2, c3, (t - 0.4) / 0.2);
    if (t < 0.8) return mix(c3, c4, (t - 0.6) / 0.2);
    return mix(c4, c5, (t - 0.8) / 0.2);
}

vec3 hot(float t) {
    t = clamp(t, 0.0, 1.0);
    return vec3(
        clamp(t * 3.0, 0.0, 1.0),
        clamp(t * 3.0 - 1.0, 0.0, 1.0),
        clamp(t * 3.0 - 2.0, 0.0, 1.0)
    );
}

vec3 cool(float t) {
    t = clamp(t, 0.0, 1.0);
    return vec3(t, 1.0 - t, 1.0);
}

vec3 bone(float t) {
    t = clamp(t, 0.0, 1.0);
    float r = t < 0.75 ? t * 8.0 / 9.0 : (t - 0.75) * 2.0 + 2.0/3.0;
    float g = t < 0.375 ? t * 8.0 / 9.0 : (t < 0.75 ? (t - 0.375) * 8.0 / 9.0 + 1.0/3.0 : (t - 0.75) * 2.0 + 2.0/3.0);
    float b = t < 0.375 ? t * 8.0 / 9.0 + 1.0/9.0 : min(1.0, 1.0/3.0 + (t - 0.375) * 16.0 / 9.0 / 1.5);
    return clamp(vec3(r, g, b), 0.0, 1.0);
}

vec3 applyColorMap(float intensity, int colorMap) {
    if (colorMap == 0) return vec3(intensity);
    if (colorMap == 1) return viridis(intensity);
    if (colorMap == 2) return plasma(intensity);
    if (colorMap == 3) return hot(intensity);
    if (colorMap == 4) return cool(intensity);
    if (colorMap == 5) return bone(intensity);
    return vec3(intensity);
}

void main() {
    vec2 uv = (vUV - 0.5) * 2.0;
    uv.x *= uResolution.x / uResolution.y;
    
    float fovRad = uFOV * 3.14159265 / 180.0;
    float tanFov = tan(fovRad * 0.5);
    
    vec3 ro = vec3(0.0, 0.0, uZoom);
    vec3 rd = normalize(vec3(uv * tanFov, -1.0));
    
    ro = uRotation * ro;
    rd = uRotation * rd;
    
    vec3 boxMin = -uAspect * 0.5;
    vec3 boxMax = uAspect * 0.5;
    
    vec2 tHit = intersectBox(ro, rd, boxMin, boxMax);
    
    if (tHit.x > tHit.y || tHit.y < 0.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    tHit.x = max(tHit.x, 0.0);
    
    float maxVal = 0.0;
    float sumVal = 0.0;
    float accumAlpha = 0.0;
    vec3 accumColor = vec3(0.0);
    int numSamples = 0;
    
    for (int i = 0; i < MAX_STEPS; i++) {
        float t = tHit.x + float(i) * STEP_SIZE;
        if (t > tHit.y) break;
        
        vec3 pos = ro + rd * t;
        vec3 texCoord = (pos - boxMin) / (boxMax - boxMin);
        
        float val = texture(uVolume, texCoord).r;
        val = max(0.0, val - uThreshold);
        
        if (uRenderMode == 0) {
            // MIP - Maximum Intensity Projection
            maxVal = max(maxVal, val);
        } else if (uRenderMode == 1) {
            // Alpha blending (front-to-back)
            float alpha = val * 0.05;
            vec3 color = applyColorMap(val * uBrightness, uColorMap);
            accumColor += (1.0 - accumAlpha) * alpha * color;
            accumAlpha += (1.0 - accumAlpha) * alpha;
            if (accumAlpha > 0.95) break;
        } else if (uRenderMode == 2) {
            // Average
            sumVal += val;
            numSamples++;
        } else if (uRenderMode == 3) {
            // X-Ray
            sumVal += val * 0.01;
        }
    }
    
    float intensity;
    if (uRenderMode == 0) {
        intensity = maxVal * uBrightness;
    } else if (uRenderMode == 1) {
        fragColor = vec4(accumColor * uBrightness, 1.0);
        return;
    } else if (uRenderMode == 2) {
        intensity = (numSamples > 0 ? sumVal / float(numSamples) : 0.0) * uBrightness;
    } else {
        intensity = (1.0 - exp(-sumVal * uBrightness));
    }
    
    intensity = pow(intensity, 1.0 / uContrast);
    intensity = clamp(intensity, 0.0, 1.0);
    
    vec3 color = applyColorMap(intensity, uColorMap);
    fragColor = vec4(color, 1.0);
}
</script>

<script>
(function() {
    'use strict';
    
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2', { 
        antialias: true, 
        preserveDrawingBuffer: true 
    });
    
    if (!gl) {
        document.getElementById('loadingText').textContent = 'WebGL2 not supported in your browser';
        return;
    }
    
    // State variables
    let volumeTexture = null;
    let program = null;
    let vao = null;
    let rotX = 0.3, rotY = 0;
    let zoom = 2.0;
    let brightness = 1.5;
    let contrast = 1.0;
    let threshold = 0;
    let speed = 1.0;
    let gaussianSize = 1.0;
    let fov = 45;
    let autoRotating = false;
    let dragging = false;
    let lastX = 0, lastY = 0;
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let fps = 0;
    let renderMode = 0;
    let colorMap = 0;
    
    // Volume dimensions (will be loaded from config)
    let dims = { x: 820, y: 650, z: 100 };
    let maxDim = Math.max(dims.x, dims.y, dims.z);
    let aspect = { x: dims.x/maxDim, y: dims.y/maxDim, z: dims.z/maxDim };
    
    // Uniform locations
    let uniforms = {};
    
    function updateProgress(percent, text) {
        document.getElementById('progressBar').style.width = percent + '%';
        document.getElementById('loadingText').textContent = text;
    }
    
    function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
    
    function createProgram(vsId, fsId) {
        const vs = createShader(gl.VERTEX_SHADER, document.getElementById(vsId).textContent);
        const fs = createShader(gl.FRAGMENT_SHADER, document.getElementById(fsId).textContent);
        
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
    
    function init() {
        updateProgress(20, 'Compiling shaders...');
        
        // Create raymarching program
        program = createProgram('raymarchVS', 'raymarchFS');
        
        // Get uniform locations
        uniforms = {
            uVolume: gl.getUniformLocation(program, 'uVolume'),
            uRotation: gl.getUniformLocation(program, 'uRotation'),
            uZoom: gl.getUniformLocation(program, 'uZoom'),
            uBrightness: gl.getUniformLocation(program, 'uBrightness'),
            uContrast: gl.getUniformLocation(program, 'uContrast'),
            uThreshold: gl.getUniformLocation(program, 'uThreshold'),
            uAspect: gl.getUniformLocation(program, 'uAspect'),
            uResolution: gl.getUniformLocation(program, 'uResolution'),
            uFOV: gl.getUniformLocation(program, 'uFOV'),
            uRenderMode: gl.getUniformLocation(program, 'uRenderMode'),
            uColorMap: gl.getUniformLocation(program, 'uColorMap')
        };
        
        // Create fullscreen quad
        const pos = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW);
        
        const loc = gl.getAttribLocation(program, 'aPos');
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
        
        updateProgress(40, 'Shaders compiled');
    }
    
    async function loadConfig() {
        try {
            const response = await fetch('dims.json');
            if (response.ok) {
                const config = await response.json();
                dims = { x: config.x || 820, y: config.y || 650, z: config.z || 100 };
                maxDim = Math.max(dims.x, dims.y, dims.z);
                aspect = { x: dims.x/maxDim, y: dims.y/maxDim, z: dims.z/maxDim };
            }
        } catch (e) {
            console.log('Using default dimensions');
        }
    }
    
    async function loadVolume() {
        updateProgress(50, 'Loading volume data...');
        
        try {
            const response = await fetch('volume.raw');
            if (!response.ok) {
                throw new Error('Volume file not found');
            }
            
            const buffer = await response.arrayBuffer();
            const data = new Uint8Array(buffer);
            
            updateProgress(70, 'Creating 3D texture...');
            
            volumeTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_3D, volumeTexture);
            gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
            gl.texImage3D(gl.TEXTURE_3D, 0, gl.R8, dims.x, dims.y, dims.z, 0, gl.RED, gl.UNSIGNED_BYTE, data);
            
            const numVoxels = dims.x * dims.y * dims.z;
            document.getElementById('numGaussians').textContent = numVoxels.toLocaleString();
            
            updateProgress(100, 'Ready!');
            return true;
        } catch (error) {
            console.error('Error loading volume:', error);
            updateProgress(100, 'Creating demo volume...');
            createDemoVolume();
            return true;
        }
    }
    
    function createDemoVolume() {
        // Create a demo volume with some interesting patterns
        dims = { x: 128, y: 128, z: 64 };
        maxDim = Math.max(dims.x, dims.y, dims.z);
        aspect = { x: dims.x/maxDim, y: dims.y/maxDim, z: dims.z/maxDim };
        
        const data = new Uint8Array(dims.x * dims.y * dims.z);
        const cx = dims.x / 2, cy = dims.y / 2, cz = dims.z / 2;
        
        for (let z = 0; z < dims.z; z++) {
            for (let y = 0; y < dims.y; y++) {
                for (let x = 0; x < dims.x; x++) {
                    const idx = x + y * dims.x + z * dims.x * dims.y;
                    
                    // Create spherical patterns
                    const dx = (x - cx) / cx;
                    const dy = (y - cy) / cy;
                    const dz = (z - cz) / cz;
                    const r = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    // Concentric shells with noise
                    let val = 0;
                    if (r < 0.8) {
                        val = Math.sin(r * 15) * 0.5 + 0.5;
                        val *= Math.exp(-r * 2);
                    }
                    
                    // Add some tubular structures
                    const tube1 = Math.sqrt(dx*dx + dz*dz);
                    if (tube1 < 0.15 && Math.abs(dy) < 0.7) {
                        val = Math.max(val, Math.exp(-tube1 * 20) * 0.8);
                    }
                    
                    const tube2 = Math.sqrt(dy*dy + dz*dz);
                    if (tube2 < 0.1 && Math.abs(dx) < 0.6) {
                        val = Math.max(val, Math.exp(-tube2 * 25) * 0.7);
                    }
                    
                    data[idx] = Math.floor(val * 255);
                }
            }
        }
        
        volumeTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_3D, volumeTexture);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
        gl.texImage3D(gl.TEXTURE_3D, 0, gl.R8, dims.x, dims.y, dims.z, 0, gl.RED, gl.UNSIGNED_BYTE, data);
        
        document.getElementById('numGaussians').textContent = (dims.x * dims.y * dims.z).toLocaleString() + ' (demo)';
    }
    
    function makeRotationMatrix(rx, ry) {
        const cx = Math.cos(rx), sx = Math.sin(rx);
        const cy = Math.cos(ry), sy = Math.sin(ry);
        return new Float32Array([
            cy, 0, sy,
            sx*sy, cx, -sx*cy,
            -cx*sy, sx, cx*cy
        ]);
    }
    
    function render() {
        // Update FPS
        frameCount++;
        const now = performance.now();
        if (now - lastFrameTime >= 1000) {
            fps = frameCount;
            frameCount = 0;
            lastFrameTime = now;
            document.getElementById('fps').textContent = fps;
        }
        
        // Auto rotation
        if (autoRotating) {
            rotY += 0.01 * speed;
        }
        
        // Setup canvas
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        gl.viewport(0, 0, canvas.width, canvas.height);
        
        document.getElementById('resolution').textContent = canvas.width + '×' + canvas.height;
        
        gl.clearColor(0.039, 0.039, 0.102, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        if (!volumeTexture) {
            requestAnimationFrame(render);
            return;
        }
        
        gl.useProgram(program);
        gl.bindVertexArray(vao);
        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_3D, volumeTexture);
        
        gl.uniform1i(uniforms.uVolume, 0);
        gl.uniformMatrix3fv(uniforms.uRotation, false, makeRotationMatrix(rotX, rotY));
        gl.uniform1f(uniforms.uZoom, zoom);
        gl.uniform1f(uniforms.uBrightness, brightness);
        gl.uniform1f(uniforms.uContrast, contrast);
        gl.uniform1f(uniforms.uThreshold, threshold);
        gl.uniform3f(uniforms.uAspect, aspect.x, aspect.y, aspect.z);
        gl.uniform2f(uniforms.uResolution, canvas.width, canvas.height);
        gl.uniform1f(uniforms.uFOV, fov);
        gl.uniform1i(uniforms.uRenderMode, renderMode);
        gl.uniform1i(uniforms.uColorMap, colorMap);
        
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        
        requestAnimationFrame(render);
    }
    
    function setupControls() {
        // Slider controls
        const controls = [
            { id: 'brightness', val: 'brightVal', prop: 'brightness', format: v => v.toFixed(1) },
            { id: 'contrast', val: 'contrastVal', prop: 'contrast', format: v => v.toFixed(1) },
            { id: 'threshold', val: 'threshVal', prop: 'threshold', format: v => v.toFixed(2) },
            { id: 'gaussianSize', val: 'sizeVal', prop: 'gaussianSize', format: v => v.toFixed(1) },
            { id: 'fov', val: 'fovVal', prop: 'fov', format: v => v + '°' },
            { id: 'zoom', val: 'zoomVal', prop: 'zoom', format: v => v.toFixed(1) },
            { id: 'speed', val: 'speedVal', prop: 'speed', format: v => v.toFixed(1) }
        ];
        
        controls.forEach(ctrl => {
            const slider = document.getElementById(ctrl.id);
            const valSpan = document.getElementById(ctrl.val);
            
            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                window[ctrl.prop] = value;
                eval(ctrl.prop + ' = ' + value);
                valSpan.textContent = ctrl.format(value);
            });
        });
        
        // Render mode
        document.getElementById('renderMode').addEventListener('change', (e) => {
            renderMode = e.target.selectedIndex;
        });
        
        // Color map
        document.getElementById('colorMap').addEventListener('change', (e) => {
            colorMap = e.target.selectedIndex;
        });
        
        // Auto rotate button
        const autoRotateBtn = document.getElementById('autoRotate');
        autoRotateBtn.addEventListener('click', () => {
            autoRotating = !autoRotating;
            autoRotateBtn.classList.toggle('active', autoRotating);
            autoRotateBtn.textContent = autoRotating ? 'Stop Rotation' : 'Auto Rotate';
        });
        
        // Reset view
        document.getElementById('resetView').addEventListener('click', () => {
            rotX = 0.3;
            rotY = 0;
            zoom = 2.0;
            document.getElementById('zoom').value = zoom;
            document.getElementById('zoomVal').textContent = zoom.toFixed(1);
        });
        
        // Screenshot
        document.getElementById('screenshot').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = '3dgs_render.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
        
        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            dragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            rotY += dx * 0.005;
            rotX += dy * 0.005;
            rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
            lastX = e.clientX;
            lastY = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => dragging = false);
        canvas.addEventListener('mouseleave', () => dragging = false);
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom += e.deltaY * 0.002;
            zoom = Math.max(0.5, Math.min(5, zoom));
            document.getElementById('zoom').value = zoom;
            document.getElementById('zoomVal').textContent = zoom.toFixed(1);
        });
        
        // Touch controls
        let touchStartDist = 0;
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                dragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                touchStartDist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                );
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && dragging) {
                const dx = e.touches[0].clientX - lastX;
                const dy = e.touches[0].clientY - lastY;
                rotY += dx * 0.005;
                rotX += dy * 0.005;
                rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                );
                zoom *= touchStartDist / dist;
                zoom = Math.max(0.5, Math.min(5, zoom));
                touchStartDist = dist;
            }
        });
        
        canvas.addEventListener('touchend', () => dragging = false);
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                autoRotating = !autoRotating;
                autoRotateBtn.classList.toggle('active', autoRotating);
                autoRotateBtn.textContent = autoRotating ? 'Stop Rotation' : 'Auto Rotate';
            } else if (e.code === 'KeyR') {
                rotX = 0.3;
                rotY = 0;
                zoom = 2.0;
            }
        });
    }
    
    // Main initialization
    async function main() {
        init();
        await loadConfig();
        await loadVolume();
        setupControls();
        
        document.getElementById('loading').style.display = 'none';
        document.getElementById('controls').style.display = 'block';
        
        render();
    }
    
    main();
})();
</script>
</body>
</html>
